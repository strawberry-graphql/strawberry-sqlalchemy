import asyncio
import collections.abc
import dataclasses
import sys
import uuid
from datetime import date, datetime, time
from decimal import Decimal
from itertools import chain
from typing import (
    TYPE_CHECKING,
    Any,
    Awaitable,
    Callable,
    Dict,
    ForwardRef,
    Generic,
    Iterable,
    List,
    Mapping,
    MutableMapping,
    NewType,
    Optional,
    Set,
    Type,
    TypeVar,
    Union,
    cast,
    get_type_hints,
)

import sentinel
import strawberry
from sqlalchemy import (
    ARRAY,
    VARCHAR,
    BigInteger,
    Boolean,
    Column,
    Date,
    DateTime,
    Enum,
    Float,
    Integer,
    LargeBinary,
    Numeric,
    SmallInteger,
    String,
    Text,
    Time,
    Unicode,
    UnicodeText,
    inspect,
)
from sqlalchemy.dialects.postgresql import UUID as SQLAlchemyUUID
from sqlalchemy.ext.associationproxy import AssociationProxy
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import (
    MANYTOMANY,
    MANYTOONE,
    ONETOMANY,
    Mapper,
    RelationshipProperty,
)
from sqlalchemy.orm.state import InstanceState
from sqlalchemy.sql.type_api import TypeEngine
from strawberry.annotation import StrawberryAnnotation
from strawberry.types import Info

from strawberry_sqlalchemy_mapper.exc import (
    HybridPropertyNotAnnotated,
    InterfaceModelNotPolymorphic,
    UnsupportedAssociationProxyTarget,
    UnsupportedColumnType,
    UnsupportedDescriptorType,
)
from strawberry_sqlalchemy_mapper.relay import (
    Connection,
    Edge,
    PageInfo,
    PagingList,
    RelativePageInput,
    cursor_from_obj,
)

Default = TypeVar("Default")

BaseModelType = TypeVar("BaseModelType")
T = TypeVar("T")
V = TypeVar("V")

SkipTypeSentinelT = NewType("SkipTypeSentinelT", object)
SkipTypeSentinel = cast(SkipTypeSentinelT, sentinel.create("SkipTypeSentinel"))


#: Set on generated types to the original type handed to the decorator
_ORIGINAL_TYPE_KEY = "_original_type"
#: Set on generated types/inputs,
# containing the list of keys of fields that were generated
_GENERATED_FIELD_KEYS_KEY = "_generated_field_keys"
#: Set on generated <Model>Connection types
_IS_GENERATED_CONNECTION_TYPE_KEY = "_is_generated_connection_type"
#: Set on resolvers generated by the mapper
_IS_GENERATED_RESOLVER_KEY = "_is_generated_resolver"
#: Set on generated types, the strawberry input type used for create mutations
_CREATE_INPUT_TYPE_KEY = "CreateInput"
#: Set on generated types, the strawberry input type used for update mutations
_UPDATE_INPUT_TYPE_KEY = "UpdateInput"


class StrawberrySQLAlchemyMapper(Generic[BaseModelType]):
    """
    Mapper for SQLAlchemy models to Strawberry types.

    Requires a consistent naming convention between SQLAlchemy
    models and Strawberry types, which is codified in `model_to_type_name`.
    By default, the convention is model name == type name,
    but you can modify it so that e.g., `BookModel` (model) -> `Book` (type).
    """

    #: Function to get the strawberry.type name for a given model
    # model_to_type_name: Callable[[Type[BaseModelType]], str]
    # model_to_create_input_name: Callable[[Type[BaseModelType]], str]
    # model_to_update_input_name: Callable[[Type[BaseModelType]], str]

    #: Function to get the strawberry.interface name
    #: for a given (polymorphic base) model
    # model_to_interface_name: Callable[[Type[BaseModelType]], str]

    #: Default mapping from sqlalchemy types to strawberry types
    _default_sqlalchemy_type_to_strawberry_type_map: Dict[
        Type[TypeEngine], Union[Type[Any], SkipTypeSentinelT]
    ] = {
        Integer: int,
        Float: float,
        BigInteger: int,
        Numeric: Decimal,
        DateTime: datetime,
        Date: date,
        Time: time,
        String: str,
        Text: str,
        Boolean: bool,
        LargeBinary: SkipTypeSentinel,
        Unicode: str,
        UnicodeText: str,
        SmallInteger: int,
        SQLAlchemyUUID: uuid.UUID,
        VARCHAR: str,
    }
    #: Mapping from sqlalchemy types to strawberry types
    sqlalchemy_type_to_strawberry_type_map: MutableMapping[
        Type[TypeEngine], Union[Type[Any], SkipTypeSentinelT]
    ]
    #: <Model>Edge types generated by the mapper
    edge_types: Dict[str, Type[Any]]
    #: <Model>Connection types generated by the mapper
    connection_types: Dict[str, Type[Any]]
    #: Model (non-interface) types generated by the mapper
    mapped_types: Dict[str, Type[Any]]
    #: Model interface types generated by the mapper
    mapped_interfaces: Dict[str, Type[Any]]
    input_model_map: Dict[Type[Any], Type[BaseModelType]]
    input_types: Dict[str, Type[Any]]
    #: All (non-interface) models that are related to currently mapped types
    #: (since we need to generate types for all relationshps)
    _related_type_models: Set[Type[BaseModelType]]
    #: All interface models that are related to currently mapped types
    _related_interface_models: Set[Type[BaseModelType]]

    def __init__(
        self,
        model_to_type_name: Optional[Callable[[Type[BaseModelType]], str]] = None,
        model_to_create_input_name: Optional[
            Callable[[Type[BaseModelType]], str]
        ] = None,
        model_to_update_input_name: Optional[
            Callable[[Type[BaseModelType]], str]
        ] = None,
        model_to_interface_name: Optional[Callable[[Type[BaseModelType]], str]] = None,
        extra_sqlalchemy_type_to_strawberry_type_map: Optional[
            Mapping[Type[TypeEngine], Type[Any]]
        ] = None,
        input_base=None,
    ) -> None:
        if TYPE_CHECKING:
            self.model_to_create_input_name: Callable[[Type[BaseModelType]], str]
            self.model_to_type_name: Callable[[Type[BaseModelType]], str]
            # self.model_to_type_name: Callable[[Type[BaseModelType]], str]
            self.model_to_interface_name: Callable[[Type[BaseModelType]], str]

        if model_to_type_name is None:
            model_to_type_name = self._default_model_to_type_name
        self.model_to_type_name = model_to_type_name
        if model_to_create_input_name is None:
            model_to_create_input_name = self._default_model_to_create_input_name
        self.model_to_create_input_name = model_to_create_input_name
        if model_to_update_input_name is None:
            model_to_update_input_name = self._default_model_to_update_input_name
        self.model_to_update_input_name = model_to_update_input_name
        if model_to_interface_name is None:
            model_to_interface_name = self._default_model_to_interface_name
        self.model_to_interface_name = model_to_interface_name
        self.sqlalchemy_type_to_strawberry_type_map = (
            self._default_sqlalchemy_type_to_strawberry_type_map.copy()
        )
        if extra_sqlalchemy_type_to_strawberry_type_map is not None:
            self.sqlalchemy_type_to_strawberry_type_map.update(
                extra_sqlalchemy_type_to_strawberry_type_map
            )
        self.edge_types = {}
        self.connection_types = {}
        self.mapped_types = {}
        self.mapped_interfaces = {}
        self.input_types = {}
        self.input_model_map = {}
        self._related_type_models = set()
        self._related_interface_models = set()
        self.input_base = (input_base,) if input_base is not None else ()

    @staticmethod
    def _default_model_to_type_name(model: Type[BaseModelType]) -> str:
        return model.__name__

    @staticmethod
    def _default_model_to_create_input_name(type_name: str) -> str:
        return f"{type_name}{_CREATE_INPUT_TYPE_KEY}"

    @staticmethod
    def _default_model_to_update_input_name(type_name: str) -> str:
        return f"{type_name}{_UPDATE_INPUT_TYPE_KEY}"

    @staticmethod
    def _default_model_to_interface_name(model: Type[BaseModelType]) -> str:
        return f"{model.__name__}Interface"

    def model_is_interface(self, model: Type[BaseModelType]) -> bool:
        """
        Whether a given SQLAlchemy model is a valid
        interface (base of a polymorphic hierarchy)
        """
        return (
            self._is_model_polymorphic(model)
            and self._get_polymorphic_base_model(model) == model
        )

    def model_to_type_or_interface_name(self, model: Type[BaseModelType]) -> str:
        """
        Get corresponding name of the corresponding type
        for the model if it's the target of a relationship
        """
        if self.model_is_interface(model):
            return self.model_to_interface_name(model)
        else:
            return self.model_to_type_name(model)

    def _is_model_polymorphic(self, model: Type[BaseModelType]) -> bool:
        """
        Whether a model is part of a polymorphic hierarchy
        """
        return inspect(model).polymorphic_on is not None

    def _edge_type_for(self, type_name: str) -> Type[Any]:
        """
        Get or create a corresponding Edge model for the given type
        (to support future pagination)
        """
        edge_name = f"{type_name}Edge"
        if edge_name not in self.edge_types:
            self.edge_types[edge_name] = edge_type = strawberry.type(
                dataclasses.make_dataclass(
                    edge_name,
                    [
                        ("node", cast(type, ForwardRef(type_name))),
                        ("cursor", str),
                    ],
                    bases=(Edge,),
                )
            )
            setattr(edge_type, _GENERATED_FIELD_KEYS_KEY, ["node"])
        return self.edge_types[edge_name]

    def _connection_type_for(self, type_name: str) -> Type[Any]:
        """
        Get or create a corresponding Connection model for the given type
        (to support future pagination)
        """
        connection_name = f"{type_name}Connection"
        if connection_name not in self.connection_types:
            self.connection_types[connection_name] = connection_type = strawberry.type(
                dataclasses.make_dataclass(
                    connection_name,
                    [
                        ("edges", List[self._edge_type_for(type_name)]),  # type: ignore
                        ("page_info", PageInfo),
                    ],
                    bases=(Connection,),
                )
            )
            setattr(connection_type, _GENERATED_FIELD_KEYS_KEY, ["edges"])
            setattr(connection_type, _IS_GENERATED_CONNECTION_TYPE_KEY, True)
        return self.connection_types[connection_name]

    def _get_polymorphic_base_model(
        self, model: Type[BaseModelType]
    ) -> Type[BaseModelType]:
        """
        Given a model, return the base of its inheritance tree (which may be itself).
        """
        return inspect(model).base_mapper.entity

    def _convert_column_to_strawberry_type(
        self, column: Column
    ) -> Union[Type[Any], SkipTypeSentinelT]:
        """
        Given a SQLAlchemy Column, return the type annotation for the field in the
        corresponding strawberry type.
        """
        if isinstance(column.type, Enum):
            type_annotation = column.type.python_type
        elif isinstance(column.type, ARRAY):
            item_type = self._convert_column_to_strawberry_type(
                Column(column.type.item_type, nullable=False)
            )
            if item_type is SkipTypeSentinel:
                return item_type
            type_annotation = List[item_type]  # type: ignore
        else:
            for (
                sqlalchemy_type,
                strawberry_type,
            ) in self.sqlalchemy_type_to_strawberry_type_map.items():
                if isinstance(column.type, sqlalchemy_type):
                    type_annotation = strawberry_type
                    break
            else:
                raise UnsupportedColumnType(column.key, column.type)
        if type_annotation is SkipTypeSentinel:
            return type_annotation
        if column.nullable:
            type_annotation = Optional[type_annotation]
        assert type_annotation is not None
        return type_annotation

    def _convert_relationship_to_strawberry_type(
        self, relationship: RelationshipProperty
    ) -> Union[Type[Any], ForwardRef]:
        """
        Given a SQLAlchemy relationship, return the type annotation for the field in the
        corresponding strawberry type.
        """
        relationship_model: Type[BaseModelType] = relationship.entity.entity
        type_name = self.model_to_type_or_interface_name(relationship_model)
        if self.model_is_interface(relationship_model):
            self._related_interface_models.add(relationship_model)
        else:
            self._related_type_models.add(relationship_model)
        if relationship.uselist:
            return self._connection_type_for(type_name)
        else:
            if self._get_relationship_is_optional(relationship):
                return Optional[ForwardRef(type_name)]  # type: ignore
            else:
                return ForwardRef(type_name)

    def _convert_relationship_to_input_type(
        self, relationship: RelationshipProperty, update: bool = False
    ):
        relationship_model: Type[BaseModelType] = relationship.entity.entity
        type_name = self.model_to_type_or_interface_name(relationship_model)

        if update:
            input_ref = ForwardRef(f"{type_name}{_UPDATE_INPUT_TYPE_KEY}")
            # input_ref = ForwardRef(f"{type_name}.{_UPDATE_INPUT_TYPE_KEY}")
        else:
            input_ref = ForwardRef(f"{type_name}{_CREATE_INPUT_TYPE_KEY}")
            # input_ref = ForwardRef(f"{type_name}.{_CREATE_INPUT_TYPE_KEY}")

        if relationship.uselist:
            input_ref = List[input_ref]  # type: ignore

        if self._get_relationship_is_optional(relationship):
            input_ref = Optional[input_ref]  # type: ignore

        return input_ref

    def _get_relationship_is_optional(self, relationship: RelationshipProperty) -> bool:
        """
        Whether the value for a relationship can be nullable
        """
        if relationship.direction in [ONETOMANY, MANYTOMANY]:
            # many on other side means it's optional always
            return True
        else:
            assert relationship.direction == MANYTOONE
            # this model is the one with the FK
            for local_col, _ in relationship.local_remote_pairs:
                if TYPE_CHECKING:
                    local_col: Column  # type: ignore
                if local_col.nullable:
                    return True
            return False

    def _add_annotation(
        self, type_: Any, key: str, annotation: Any, generated_field_keys: List[str]
    ) -> None:
        """
        Add type annotation to the given type.
        """
        type_.__annotations__[key] = annotation
        generated_field_keys.append(key)

    def _get_association_proxy_annotation(
        self, mapper: Mapper, key: str, descriptor: Any
    ) -> Union[Type[Any], ForwardRef, SkipTypeSentinelT]:
        """
        Given an association proxy, return the type annotation
        for it. This only supports association proxies that
        are of the form (relationship, relationship).
        """
        is_multiple = mapper.relationships[descriptor.target_collection].uselist
        in_between_mapper: Mapper = mapper.relationships[
            descriptor.target_collection
        ].entity
        if descriptor.value_attr in in_between_mapper.relationships:
            relationship = in_between_mapper.relationships[descriptor.value_attr]
            is_multiple = is_multiple or relationship.uselist
            strawberry_type = self._convert_relationship_to_strawberry_type(
                relationship
            )
        else:
            raise UnsupportedAssociationProxyTarget(key)
        if strawberry_type is SkipTypeSentinel:
            return strawberry_type
        if is_multiple and not self._is_connection_type(
            cast(Union[Type[Any], ForwardRef], strawberry_type)
        ):
            if isinstance(strawberry_type, ForwardRef):
                strawberry_type = self._connection_type_for(
                    strawberry_type.__forward_arg__
                )
            else:
                strawberry_type = self._connection_type_for(
                    cast(Type[Any], strawberry_type).__name__
                )
        return strawberry_type

    def make_connection_wrapper_resolver(
        self, resolver: Callable[..., Awaitable[Any]], type_name: str, connection_type
    ) -> Callable[..., Awaitable[Any]]:
        """
        Wrap a resolver that returns an array of model types to return
        a Connection instead.
        """
        # connection_type = self._connection_type_for(type_name)
        edge_type = self._edge_type_for(type_name)

        async def wrapper(
            self, info: Info, page_input: Optional[RelativePageInput] = None
        ):
            objects = await resolver(self, info, page_input)
            return connection_type(
                edges=[
                    edge_type(
                        node=related_object,
                        cursor=cursor_from_obj(related_object),
                    )
                    for related_object in objects
                ],
                page_info=objects.page_info,
            )

        setattr(wrapper, _IS_GENERATED_RESOLVER_KEY, True)

        return wrapper

    def relationship_resolver_for(
        self, relationship: RelationshipProperty
    ) -> Callable[..., Awaitable[Any]]:
        """
        Return an async field resolver for the given relationship,
        so as to avoid n+1 query problem.
        """

        async def resolve(
            self, info: Info, page_input: Optional[RelativePageInput] = None
        ):
            instance_state = cast(InstanceState, inspect(self))
            if relationship.key not in instance_state.unloaded:
                objects = getattr(self, relationship.key)
                related_objects = PagingList([obj for obj in objects])

                if page_input is not None:
                    related_objects = related_objects.page(page_input)

                elif related_objects:
                    related_objects.set_page_info(
                        PageInfo(
                            False,
                            False,
                            cursor_from_obj(objects[0]),
                            cursor_from_obj(objects[-1]),
                        )
                    )
                    # related_objects[0].page_info = page_info

            else:
                relationship_key = tuple(
                    [
                        getattr(self, local.key)
                        for local, _ in relationship.local_remote_pairs
                    ]
                )
                if any(item is None for item in relationship_key):
                    if relationship.uselist:
                        return []
                    else:
                        return None
		if isinstance(info.context, dict):
                    loader = info.context["sqlalchemy_loader"]
                else:
                    loader = info.context.sqlalchemy_loader
                related_objects = (
                    await loader
                    .loader_for(relationship)
                    .load((page_input, relationship_key))
                )
            return related_objects

        setattr(resolve, _IS_GENERATED_RESOLVER_KEY, True)

        if not relationship.uselist:

            async def resolve_no_list(self, info: Info):
                return await resolve(self, info, page_input=None)

            # resolve = resolve_no_list
            return resolve_no_list

        return resolve

    def connection_resolver_for(
        self, relationship: RelationshipProperty
    ) -> Callable[..., Awaitable[Any]]:
        """
        Return an async field resolver for the given relationship that
        returns a Connection instead of an array of objects.
        """
        type_name = self.model_to_type_or_interface_name(relationship.entity.entity)
        connection_type = self._connection_type_for(type_name)
        relationship_resolver = self.relationship_resolver_for(relationship)

        if relationship.uselist:
            return self.make_connection_wrapper_resolver(
                relationship_resolver,
                type_name,
                connection_type
                # self.model_to_type_or_interface_name(relationship.entity.entity),
            )
        else:
            return relationship_resolver

    def _is_connection_type(self, type_: Union[Type[Any], ForwardRef]) -> bool:
        """
        Returns whether a given type is a <Model>Connection type.
        """
        return getattr(type_, _IS_GENERATED_CONNECTION_TYPE_KEY, False)

    def association_proxy_resolver_for(
        self, mapper: Mapper, descriptor: Any, strawberry_type: Type
    ) -> Callable[..., Awaitable[Any]]:
        """
        Return an async field resolver for the given association proxy.
        """
        in_between_relationship = mapper.relationships[descriptor.target_collection]
        in_between_resolver = self.relationship_resolver_for(in_between_relationship)
        in_between_mapper: Mapper = mapper.relationships[
            descriptor.target_collection
        ].entity
        assert descriptor.value_attr in in_between_mapper.relationships
        end_relationship = in_between_mapper.relationships[descriptor.value_attr]
        end_relationship_resolver = self.relationship_resolver_for(end_relationship)
        end_type_name = self.model_to_type_or_interface_name(
            end_relationship.entity.entity
        )
        connection_type = self._connection_type_for(end_type_name)
        edge_type = self._edge_type_for(end_type_name)
        is_multiple = self._is_connection_type(strawberry_type)

        async def resolve(self, info: Info):
            in_between_objects = await in_between_resolver(self, info)
            if in_between_objects is None:
                if is_multiple:
                    return connection_type(edges=[])
                else:
                    return None
            if descriptor.value_attr in in_between_mapper.relationships:
                assert end_relationship_resolver is not None
                if isinstance(in_between_objects, collections.abc.Iterable):
                    outputs = await asyncio.gather(
                        *[
                            end_relationship_resolver(obj, info)
                            for obj in in_between_objects
                        ]
                    )
                    if outputs and isinstance(outputs[0], list):
                        outputs = list(chain.from_iterable(outputs))
                    else:
                        outputs = [output for output in outputs if output is not None]
                else:
                    outputs = await end_relationship_resolver(in_between_objects, info)
                if not isinstance(outputs, collections.abc.Iterable):
                    return outputs
                return connection_type(edges=[edge_type(node=obj) for obj in outputs])
            else:
                assert descriptor.value_attr in in_between_mapper.columns
                if isinstance(in_between_objects, collections.abc.Iterable):
                    return [
                        getattr(obj, descriptor.value_attr)
                        for obj in in_between_objects
                    ]
                else:
                    return getattr(in_between_objects, descriptor.value_attr)

        setattr(resolve, _IS_GENERATED_RESOLVER_KEY, True)
        return resolve

    def _is_optional(self, type_: Any) -> bool:
        return getattr(type_, "_name", None) == "Optional"

    def _handle_columns(
        self,
        mapper: Mapper,
        type_: Any,
        excluded_keys: Iterable[str],
        generated_field_keys: List[str],
        all_optional: bool = False,
    ) -> None:
        """
        Add annotations for the columns of the given mapper.
        """
        for key, column in mapper.columns.items():
            column: Column  # type: ignore
            if (
                key in excluded_keys
                or key in type_.__annotations__
                or hasattr(type_, key)
            ):
                continue
            type_annotation = self._convert_column_to_strawberry_type(column)
            if all_optional and not self._is_optional(type_annotation):
                type_annotation = Optional[type_annotation]
            if type_annotation is not SkipTypeSentinel:
                self._add_annotation(
                    type_,
                    key,
                    type_annotation,
                    generated_field_keys,
                )

    def _get_pk_field(self, model) -> List[str]:
        mapper = model.__mapper__
        return [
            mapper.get_property_by_column(column).key for column in mapper.primary_key
        ]

    def type(
        self,
        model: Type[BaseModelType],
        make_interface=False,
    ) -> Callable[[Type[object]], type]:
        """
        Decorate a type with this to register it as a strawberry type
        for the given SQLAlchemy model. This will automatically add fields
        for the model's columns, relationships, association proxies, and hybrid
        properties. For example:

        ```
        class Employee(Model):
            id = Column(UUID, primary_key=True)
            name = Column(String, nullable=False)


        # in another file
        strawberry_sqlalchemy_mapper = StrawberrySQLAlchemyMapper()
        @strawberry_sqlalchemy_mapper.type(models.Employee)
        class Employee:
            pass
        ```
        """

        def convert(type_: Any) -> type:
            old_annotations = getattr(type_, "__annotations__", {})
            type_.__annotations__ = {}
            mapper: Mapper = inspect(model)
            generated_field_keys = []

            excluded_keys = getattr(type_, "__exclude__", [])

            # if the type inherits from another mapped type, then it may have
            # generated resolvers. These will be treated by dataclasses as having
            # a default value, which will likely cause issues because of keys
            # that don't have default values. To fix this, we wrap them in
            # `strawberry.field()` (like when they were originally made), so
            # dataclasses will ignore them.
            # TODO: Potentially raise/fix this issue upstream
            for key in dir(type_):
                val = getattr(type_, key)
                if getattr(val, _IS_GENERATED_RESOLVER_KEY, False):
                    setattr(type_, key, strawberry.field(resolver=val))
                    generated_field_keys.append(key)

            self._handle_columns(mapper, type_, excluded_keys, generated_field_keys)

            for key, relationship in mapper.relationships.items():
                relationship: RelationshipProperty  # type: ignore
                if (
                    key in excluded_keys
                    or key in type_.__annotations__
                    or hasattr(type_, key)
                ):
                    continue
                strawberry_type = self._convert_relationship_to_strawberry_type(
                    relationship
                )

                self._add_annotation(
                    type_,
                    key,
                    strawberry_type,
                    generated_field_keys,
                )
                field = strawberry.field(
                    resolver=self.connection_resolver_for(relationship)
                )
                assert not field.init
                setattr(
                    type_,
                    key,
                    field,
                )
            for key, descriptor in mapper.all_orm_descriptors.items():
                if (
                    key in excluded_keys
                    or key in type_.__annotations__
                    or hasattr(type_, key)
                ):
                    continue
                if key in mapper.columns or key in mapper.relationships:
                    continue
                if isinstance(descriptor, AssociationProxy):
                    strawberry_type = self._get_association_proxy_annotation(
                        mapper, key, descriptor
                    )
                    if strawberry_type is SkipTypeSentinel:
                        continue
                    self._add_annotation(
                        type_, key, strawberry_type, generated_field_keys
                    )
                    field = strawberry.field(
                        resolver=self.association_proxy_resolver_for(
                            mapper, descriptor, strawberry_type
                        )
                    )
                    assert not field.init
                    setattr(type_, key, field)
                elif isinstance(descriptor, hybrid_property):
                    if (
                        not hasattr(descriptor, "__annotations__")
                        or "return" not in descriptor.__annotations__
                    ):
                        raise HybridPropertyNotAnnotated(key)
                    self._add_annotation(
                        type_,
                        key,
                        descriptor.__annotations__["return"],
                        generated_field_keys,
                    )
                else:
                    raise UnsupportedDescriptorType(key)

            # ignore inherited `is_type_of`
            if "is_type_of" not in type_.__dict__:
                type_.is_type_of = (
                    lambda obj, info: type(obj) == model or type(obj) == type_
                )

            # need to make fields that are already in the type
            # (prior to mapping) appear *after* the mapped fields
            # because the pre-existing fields might have default values,
            # which will cause the mapped fields to fail
            # (because they may not have default values)
            type_.__annotations__.update(old_annotations)

            if make_interface:
                mapped_type = strawberry.interface(type_)
                self.mapped_interfaces[type_.__name__] = mapped_type
            else:
                mapped_type = strawberry.type(type_)
                self.mapped_types[type_.__name__] = mapped_type

            setattr(mapped_type, _GENERATED_FIELD_KEYS_KEY, generated_field_keys)
            setattr(mapped_type, _ORIGINAL_TYPE_KEY, type_)

            return mapped_type

        return convert

    def _input(self, model: Type[BaseModelType], update: bool = False):
        def convert(type_: Any):
            old_annotations = getattr(type_, "__annotations__", {})
            type_.__annotations__ = {}
            mapper: Mapper = inspect(model)
            generated_field_keys: List[str] = []
            excluded_keys = getattr(type_, "__exclude__", [])

            pk_field = self._get_pk_field(model)

            # Exclude primary keys from create input
            if not update:
                excluded_keys = set(excluded_keys).union(pk_field)

            type_name = self.model_to_type_name(model)

            if update:
                input_name = self.model_to_update_input_name(type_name)
            else:
                input_name = self.model_to_create_input_name(type_name)

            type_.__name__ = input_name

            if update:
                # Update input
                self._handle_columns(
                    mapper,
                    type_,
                    excluded_keys,
                    generated_field_keys,
                    all_optional=True,
                )
                # Set none defaults for all fields on update class
                for f in generated_field_keys:
                    if f not in pk_field:
                        setattr(type_, f, None)

            else:
                # Create input
                self._handle_columns(
                    mapper,
                    type_,
                    excluded_keys,
                    generated_field_keys,
                )

            for key, relationship in mapper.relationships.items():
                relationship: RelationshipProperty  # type: ignore
                if (
                    key in excluded_keys
                    or key in type_.__annotations__
                    or hasattr(type_, key)
                ):
                    continue

                relationship_input = self._convert_relationship_to_input_type(
                    relationship, update
                )
                if key not in excluded_keys:
                    self._add_annotation(
                        type_,
                        key,
                        relationship_input,
                        generated_field_keys,
                    )
                    if relationship.uselist:
                        setattr(
                            type_,
                            key,
                            strawberry.field(default_factory=list),
                        )
                    elif update:
                        setattr(type_, key, None)

            type_.__annotations__.update(old_annotations)

            # Cast pk field to strawberry ID
            if update:
                type_.__annotations__.update({pk: strawberry.ID for pk in pk_field})

            mapped_input = strawberry.input(type_)

            setattr(
                mapped_input,
                _GENERATED_FIELD_KEYS_KEY,
                generated_field_keys,
            )

            self.input_types[input_name] = mapped_input
            self.input_model_map[mapped_input] = model

            return mapped_input

        return convert

    def create_input(self, model: Type[BaseModelType]) -> Callable[[type], type]:
        return self._input(model)

    def update_input(self, model: Type[BaseModelType]) -> Callable[[type], type]:
        return self._input(model, update=True)

    def interface(self, model: Type[BaseModelType]) -> Callable[[Type[object]], Any]:
        """
        Decorate a type with this to register it as a strawberry interface for
        the given SQLAlchemy model.
        """
        if (
            not self._is_model_polymorphic(model)
            or self._get_polymorphic_base_model(model) != model
        ):
            raise InterfaceModelNotPolymorphic(model)
        return self.type(model, make_interface=True)

    def finalize(self) -> None:
        """
        Finalize right before initializing the strawberry Schema.
        Not performing this step may result in confusing errors
        from graphql-core and/or strawberry.
        """
        self._map_unmapped_relationships()
        self._fix_annotation_namespaces()

    def _fix_annotation_namespaces(self) -> None:
        """
        Modify the namespaces of the fields of the generated types by this
        mapper to include references to *other* generated types by this mapper,
        so that the types of relationships can resolve to generated types that
        may not be in the module of the referring type.
        """
        for mapped_type in chain(
            self.mapped_types.values(),
            self.mapped_interfaces.values(),
            self.edge_types.values(),
            self.connection_types.values(),
            self.input_types.values(),
        ):
            # Evaluate forwardrefs
            globalsns = {
                **self.mapped_types,
                **self.mapped_interfaces,
                **self.edge_types,
                **self.connection_types,
                **self.input_types,
            }
            mapped_type.__annotations__ = get_type_hints(mapped_type, localns=globalsns)

            for field in mapped_type._type_definition.fields:
                if field.name in getattr(mapped_type, _GENERATED_FIELD_KEYS_KEY):
                    namespace = {}
                    if hasattr(mapped_type, _ORIGINAL_TYPE_KEY):
                        namespace.update(
                            sys.modules[
                                getattr(mapped_type, _ORIGINAL_TYPE_KEY).__module__
                            ].__dict__
                        )
                    namespace.update(self.mapped_types)
                    namespace.update(self.mapped_interfaces)
                    namespace.update(self.edge_types)
                    namespace.update(self.connection_types)
                    namespace.update(self.input_types)
                    if not hasattr(field, "type_annotation"):
                        field.type_annotation = StrawberryAnnotation(
                            field.type, namespace=namespace
                        )
                    else:
                        field.type_annotation.namespace = namespace

    def _map_unmapped_relationships(self) -> None:
        """
        Map strawberry types and interfaces for (transitively) related models.
        """
        unmapped_model_found = True
        while unmapped_model_found:
            unmapped_models = set()
            unmapped_interface_models = set()
            for model in self._related_type_models:
                type_name = self.model_to_type_name(model)
                if type_name not in self.mapped_types:
                    unmapped_models.add(model)
            for model in self._related_interface_models:
                type_name = self.model_to_interface_name(model)
                if type_name not in self.mapped_interfaces:
                    unmapped_interface_models.add(model)
            for model in unmapped_models:
                self.type(model)(type(self.model_to_type_name(model), (object,), {}))
            for model in unmapped_interface_models:
                self.interface(model)(
                    type(self.model_to_interface_name(model), (object,), {})
                )
            unmapped_model_found = (
                len(unmapped_models) > 0 or len(unmapped_interface_models) > 0
            )
